### ëª¨ë¸/ì•± ì†Œê°œ ë° ë‹¤ìš´ë¡œë“œ                                                                                
+ LICENSEë¥¼ ê¼­ ì½ì–´ ì£¼ì„¸ìš”.                                                                                                                                                                                                 
+ ì™„ì „í•œ ë¡œì»¬ ëª¨ë¸/ì•±ìœ¼ë¡œ ì•ˆì‹¬í•˜ê³  ì‚¬ìš©í•˜ì…”ë„ ì¢‹ìŠµë‹ˆë‹¤. ë§Œì•½ ë¬¸ì œê°€ ë°œìƒí•˜ë©´ ë°”ë¡œ ì‚­ì œí•˜ê³  ì €ì—ê²Œ ì•Œë ¤ì£¼ì„¸ìš”.
+ ì™„ì „í•œ ë¡œì»¬ì´ë¯€ë¡œ ê´‘ê³ ê°€ ë‚˜ì˜¤ì§€ ì•ŠìŠµë‹ˆë‹¤.
+ ì•±ì€ exe íŒŒì¼ì…ë‹ˆë‹¤. ë‹¤ë¥¸ í™•ì¥ìë¡œëŠ” ì œì‘í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
+ ì•±ì€ python ì½”ë“œë¥¼ Pyinstallerë¥¼ ì´ìš©í•´ exeë¡œ ë¹Œë“œí•˜ì˜€ìŠµë‹ˆë‹¤.
+ ë³¸ ëª¨ë¸ì€ í•œêµ­ì–´ ëª¨ë¸ì…ë‹ˆë‹¤.

ëª¨ë¸ ë‹¤ìš´ë¡œë“œ:                                                                                                   
[seq2seq_98000.h5](https://drive.google.com/file/d/13jwVJKOXsGiRwoMHI9dASlYEUsulsxs_/view?usp=drive_link)       
[seq2seq_90000.h5](https://drive.google.com/file/d/1eCgpFWnyJSX-JgShrnCTm4-LDit_cB0T/view?usp=drive_link)       
[seq2seq_50000.h5](https://drive.google.com/file/d/19tm0EH82sRCQQUbho6bLicw80kc1TI0s/view?usp=drive_link)       
ì•± ë‹¤ìš´ë¡œë“œ:                                                                                                     



+ ìƒì—…ì  ì‚¬ìš©ì„ ì œì™¸í•˜ë©´ ë­ë“  ê´œì°®ìŠµë‹ˆë‹¤. ì–¼ë§ˆë“ ì§€ ì‚¬ìš©í•´ ì£¼ì„¸ìš” 

### ë¶€íƒê³¼ ë°‘ë°¥

+ ë…í•™ìœ¼ë¡œ ë§Œë“  ì²« ëª¨ë¸ë“¤ì´ë¼ ì„±ëŠ¥ì´ ë‚®ì„ ìˆ˜ ìˆì–´ìš”.
+ License ì œë°œ ì½ì–´ ì£¼ì„¸ìš”.
+ ë…¸íŠ¸ë¶ìœ¼ë¡œ ë”¥ëŸ¬ë‹ì„ ëŒë¦¬ê¸° ë•Œë¬¸ì— ê±¸ë¦¬ëŠ” ì‹œê°„ ëŒ€ë¹„ ëª¨ë¸ ì„±ëŠ¥ì´ ë‚®ì„ ìˆ˜ ìˆì–´ìš”.
+ ëª¨ë¸ íŒŒì¼ì´ í¬ë‹¤ë³´ë‹ˆ êµ¬ê¸€ì—ì„œ ë°”ì´ëŸ¬ìŠ¤ ê²€ì‚¬ë¥¼ ëª»í•œë‹¤ëŠ” íŒì—…ì´ ë‚˜ì˜¬ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
+ ì•ˆì‹¬í•˜ê³  ì‚¬ìš©í•´ì£¼ì„¸ìš”. Github ì‚¬ìš©ì´ ì„œíˆ´ì–´ì„œ ë„£ì§€ ëª»í•œ ê²Œ ìˆì„ ìˆ˜ ìˆì§€ë§Œ ê³µê°œí•  ìˆ˜ ìˆëŠ” ëª¨ë“  ê²ƒì„ ê³µê°œí•˜ê³  ìˆì–´ìš”.
+ Seq2SeqëŠ” ëª¨ë‘ ê°™ì€ í† í¬ë‚˜ì´ì €ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤. í•™ìŠµëŸ‰ì˜ ì°¨ì´ê°€ ìˆì„ ë¿ ì…ë‹ˆë‹¤.
+ Transformerì˜ í† í¬ë‚˜ì´ì €ëŠ” Seq2Seqì™€ ê°™ì§€ ì•ŠìŠµë‹ˆë‹¤.

### ì¶”ì²œí•˜ëŠ” ê²ƒ

+ ëª¨ë¸ê³¼ í† í¬ë‚˜ì´ì €ë¥¼ ë‹¤ìš´ë¡œë“œí•˜ì—¬ GUIë¥¼ ì§ì ‘ êµ¬í˜„í•˜ëŠ” ê²ƒë„ ì¢‹ì§€ë§Œ, í•¨ê»˜ ê³µê°œì¤‘ì¸ ì•±ë„ ì‚¬ìš©í•´ ë³´ëŠ” ê²ƒì„ ì¶”ì²œí•©ë‹ˆë‹¤.

### ê·œì¹™

+ ìƒì—…ì  ì‚¬ìš©(ëˆì„ ë²Œê¸° ìœ„í•œ ìˆ˜ë‹¨ìœ¼ë¡œ ì‚¬ìš©)ì„ í—ˆê°€í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ê°œì¸ ë˜ëŠ” ë‹¨ì²´ì˜ ë¹„ì˜ë¦¬ ì‚¬ìš©ë§Œ í—ˆìš©í•©ë‹ˆë‹¤.
### ì•± ì½”ë“œ
```bash
import sys
import re
import random
import pickle
import numpy as np
import tensorflow as tf
from PySide6.QtWidgets import QApplication, QWidget, QVBoxLayout, QLineEdit, QPushButton, QLabel, QScrollArea, QSlider, QComboBox
from PySide6.QtCore import Qt


greetings = [r"\bì•ˆë…•\b", r"\bì•ˆë…•í•˜ì„¸ìš”\b", r"\bë°˜ê°€ì›Œ\b", r"\bí•˜ì´\b", r"\bì˜ ì§€ë‚´\b"]
greeting_responses = ["ì•ˆë…•í•˜ì„¸ìš”! ğŸ˜Š", "ë°˜ê°‘ìŠµë‹ˆë‹¤!", "ì•ˆë…•! ì¢‹ì€ í•˜ë£¨ ë³´ë‚´!", "í•˜ì´~ ë­ ë„ì™€ì¤„ê¹Œ?"]

name_questions = [r"\bì´ë¦„ì´ ë­ì•¼\b", r"\bë„ˆ ëˆ„êµ¬ì•¼\b", r"\bë„ˆì˜ ì´ë¦„ì€\b", r"\bë„ˆ ë­ì•¼\b"]
name_responses = ["ë‚´ ì´ë¦„ì€ ë§ˆìŒì´ì•¼!", "ë‚œ ì±—ë´‡ ë§ˆìŒì´ì•¼, ë°˜ê°€ì›Œ!", "ë§ˆìŒì´ë¼ê³  ë¶ˆëŸ¬ì¤˜! ğŸ˜Š"]


def load_model(model_name):
    if model_name == "ê¸°ë³¸ ëª¨ë¸":
        model = tf.keras.models.load_model("seq2seq_model_90000.h5")
    elif model_name == "ê³ ê¸‰ ëª¨ë¸":
        model = tf.keras.models.load_model("seq2seq_model_98000.h5")
    elif model_name == "ë¹ ë¥¸ ëª¨ë¸":
        model = tf.keras.models.load_model("seq2seq_model_50000.h5")
    
    with open(f"tokenizer.pkl", "rb") as f:
        tokenizer = pickle.load(f)
    
    return model, tokenizer


model, tokenizer = load_model("ê¸°ë³¸ ëª¨ë¸")

start_token = "<start>"
end_token = "<end>"


encoder_inputs = model.input[0]
encoder_embedding = model.layers[2]
encoder_gru = model.layers[4]
encoder_outputs, state_h = encoder_gru(encoder_embedding(encoder_inputs))
encoder_model = tf.keras.Model(encoder_inputs, [encoder_outputs, state_h])


decoder_inputs = model.input[1]
decoder_embedding = model.layers[3]
decoder_state_input_h = tf.keras.Input(shape=(136,))
decoder_embedded = decoder_embedding(decoder_inputs)
decoder_gru = model.layers[5]
decoder_outputs, decoder_state_h = decoder_gru(decoder_embedded, initial_state=decoder_state_input_h)
decoder_dense = model.layers[6]
decoder_outputs = decoder_dense(decoder_outputs)
decoder_model = tf.keras.Model([decoder_inputs, decoder_state_input_h], [decoder_outputs, decoder_state_h])


def is_greeting(text):
    return any(re.search(pattern, text.lower()) for pattern in greetings)

def is_name_question(text):
    return any(re.search(pattern, text.lower()) for pattern in name_questions)


def chatbot_response(user_input, temperature=0.7):
    if is_greeting(user_input):
        return random.choice(greeting_responses)
    elif is_name_question(user_input):
        return random.choice(name_responses)
    return chat_with_model(user_input, temperature)


def chat_with_model(input_text, temperature):
    input_seq = tokenizer.texts_to_sequences([input_text])
    input_seq = tf.keras.preprocessing.sequence.pad_sequences(input_seq, maxlen=40, padding="post")

    encoder_output, state_h = encoder_model.predict(input_seq)
    target_seq = np.array([[tokenizer.word_index[start_token]]])
    stop_condition = False
    decoded_sentence = ""
    prev_words = []

    max_output_length = 58
    while not stop_condition:
        output_tokens, h = decoder_model.predict([target_seq, state_h])
        preds = np.asarray(output_tokens[0, -1, :]).astype("float64")
        preds = np.log(preds + 1e-8) / temperature
        exp_preds = np.exp(preds)
        preds = exp_preds / np.sum(exp_preds)

        sampled_token_index = np.random.choice(len(preds), p=preds)
        sampled_word = tokenizer.index_word.get(sampled_token_index, "")

        if not sampled_word or sampled_word in prev_words:
            continue

        prev_words.append(sampled_word)
        if len(prev_words) > 3:
            prev_words.pop(0)

        if sampled_word == end_token or len(decoded_sentence.split()) >= max_output_length:
            stop_condition = True
        else:
            decoded_sentence += " " + sampled_word

        target_seq = np.array([[sampled_token_index]])
        state_h = h

    return decoded_sentence.strip()


class ChatWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Chatbot GUI")
        self.setGeometry(100, 100, 400, 600)
        layout = QVBoxLayout()

        
        self.model_selector = QComboBox(self)
        self.model_selector.addItem("ê¸°ë³¸ ëª¨ë¸")
        self.model_selector.addItem("ê³ ê¸‰ ëª¨ë¸")
        self.model_selector.addItem("ë¹ ë¥¸ ëª¨ë¸")
        self.model_selector.currentTextChanged.connect(self.change_model)
        
        self.chat_area = QScrollArea(self)
        self.chat_widget = QWidget()
        self.chat_layout = QVBoxLayout()
        self.chat_widget.setLayout(self.chat_layout)
        self.chat_area.setWidget(self.chat_widget)
        self.chat_area.setWidgetResizable(True)

        self.text_input = QLineEdit(self)
        self.text_input.setPlaceholderText("ë©”ì‹œì§€ë¥¼ ì…ë ¥í•˜ì„¸ìš”...")
        self.text_input.returnPressed.connect(self.send_message)

        self.send_button = QPushButton("ë³´ë‚´ê¸°", self)
        self.send_button.clicked.connect(self.send_message)

        self.temperature_slider = QSlider(Qt.Horizontal)
        self.temperature_slider.setMinimum(10)
        self.temperature_slider.setMaximum(100)
        self.temperature_slider.setValue(70)
        self.temperature_slider.valueChanged.connect(self.update_temperature)
        self.temperature_label = QLabel(f"Temperature: {self.temperature_slider.value() / 100:.2f}", self)

        layout.addWidget(QLabel("ëª¨ë¸ ì„ íƒ:"))
        layout.addWidget(self.model_selector)
        layout.addWidget(self.temperature_label)
        layout.addWidê³ 
+ ëª¨ë¸ ì½”ë“œëŠ” Seq2Seq.py, Transformer.pyë¥¼ í™•ì¸í•´ ì£¼ì„¸ìš”
