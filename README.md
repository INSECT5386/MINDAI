### ëª¨ë¸/ì•± ì†Œê°œ ë° ë‹¤ìš´ë¡œë“œ                                                                                
+ LICENSEë¥¼ ê¼­ ì½ì–´ ì£¼ì„¸ìš”.                                                                                                                                                                                                 
+ ì™„ì „í•œ ë¡œì»¬ ëª¨ë¸/ì•±ìœ¼ë¡œ ì•ˆì‹¬í•˜ê³  ì‚¬ìš©í•˜ì…”ë„ ì¢‹ìŠµë‹ˆë‹¤. ë§Œì•½ ë¬¸ì œê°€ ë°œìƒí•˜ë©´ ë°”ë¡œ ì‚­ì œí•˜ê³  ì €ì—ê²Œ ì•Œë ¤ì£¼ì„¸ìš”.
+ ì™„ì „í•œ ë¡œì»¬ì´ë¯€ë¡œ ê´‘ê³ ê°€ ë‚˜ì˜¤ì§€ ì•ŠìŠµë‹ˆë‹¤.
+ ì•±ì€ exe íŒŒì¼ì…ë‹ˆë‹¤. ë‹¤ë¥¸ í™•ì¥ìë¡œëŠ” ì œì‘í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
+ ì•±ì€ python ì½”ë“œë¥¼ Pyinstallerë¥¼ ì´ìš©í•´ exeë¡œ ë¹Œë“œí•˜ì˜€ìŠµë‹ˆë‹¤.
+ ë³¸ ëª¨ë¸ì€ í•œêµ­ì–´ ëª¨ë¸ì…ë‹ˆë‹¤.

ëª¨ë¸ ë‹¤ìš´ë¡œë“œ:                                                                                                   
[seq2seq_98000.h5](https://drive.google.com/file/d/13jwVJKOXsGiRwoMHI9dASlYEUsulsxs_/view?usp=drive_link)       
[seq2seq_90000.h5](https://drive.google.com/file/d/1eCgpFWnyJSX-JgShrnCTm4-LDit_cB0T/view?usp=drive_link)       
[seq2seq_50000.h5](https://drive.google.com/file/d/19tm0EH82sRCQQUbho6bLicw80kc1TI0s/view?usp=drive_link) 

[Seq2Seq_tokenizer]
ì•± ë‹¤ìš´ë¡œë“œ:                                                                                                     



+ ìƒì—…ì  ì‚¬ìš©ì„ ì œì™¸í•˜ë©´ ë­ë“  ê´œì°®ìŠµë‹ˆë‹¤. ì–¼ë§ˆë“ ì§€ ì‚¬ìš©í•´ ì£¼ì„¸ìš” 

### ë¶€íƒê³¼ ë°‘ë°¥

+ ë…í•™ìœ¼ë¡œ ë§Œë“  ì²« ëª¨ë¸ë“¤ì´ë¼ ì„±ëŠ¥ì´ ë‚®ì„ ìˆ˜ ìˆì–´ìš”.
+ License ì œë°œ ì½ì–´ ì£¼ì„¸ìš”.
+ ë…¸íŠ¸ë¶ìœ¼ë¡œ ë”¥ëŸ¬ë‹ì„ ëŒë¦¬ê¸° ë•Œë¬¸ì— ê±¸ë¦¬ëŠ” ì‹œê°„ ëŒ€ë¹„ ëª¨ë¸ ì„±ëŠ¥ì´ ë‚®ì„ ìˆ˜ ìˆì–´ìš”.
+ ëª¨ë¸ íŒŒì¼ì´ í¬ë‹¤ë³´ë‹ˆ êµ¬ê¸€ì—ì„œ ë°”ì´ëŸ¬ìŠ¤ ê²€ì‚¬ë¥¼ ëª»í•œë‹¤ëŠ” íŒì—…ì´ ë‚˜ì˜¬ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
+ ì•ˆì‹¬í•˜ê³  ì‚¬ìš©í•´ì£¼ì„¸ìš”. Github ì‚¬ìš©ì´ ì„œíˆ´ì–´ì„œ ë„£ì§€ ëª»í•œ ê²Œ ìˆì„ ìˆ˜ ìˆì§€ë§Œ ê³µê°œí•  ìˆ˜ ìˆëŠ” ëª¨ë“  ê²ƒì„ ê³µê°œí•˜ê³  ìˆì–´ìš”.
+ Seq2SeqëŠ” ëª¨ë‘ ê°™ì€ í† í¬ë‚˜ì´ì €ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤. í•™ìŠµëŸ‰ì˜ ì°¨ì´ê°€ ìˆì„ ë¿ ì…ë‹ˆë‹¤.
+ Transformerì˜ í† í¬ë‚˜ì´ì €ëŠ” Seq2Seqì™€ ê°™ì§€ ì•ŠìŠµë‹ˆë‹¤.

### ì¶”ì²œí•˜ëŠ” ê²ƒ

+ ëª¨ë¸ê³¼ í† í¬ë‚˜ì´ì €ë¥¼ ë‹¤ìš´ë¡œë“œí•˜ì—¬ GUIë¥¼ ì§ì ‘ êµ¬í˜„í•˜ëŠ” ê²ƒë„ ì¢‹ì§€ë§Œ, í•¨ê»˜ ê³µê°œì¤‘ì¸ ì•±ë„ ì‚¬ìš©í•´ ë³´ëŠ” ê²ƒì„ ì¶”ì²œí•©ë‹ˆë‹¤.

### ê·œì¹™

+ ìƒì—…ì  ì‚¬ìš©(ëˆì„ ë²Œê¸° ìœ„í•œ ìˆ˜ë‹¨ìœ¼ë¡œ ì‚¬ìš©)ì„ í—ˆê°€í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ê°œì¸ ë˜ëŠ” ë‹¨ì²´ì˜ ë¹„ì˜ë¦¬ ì‚¬ìš©ë§Œ í—ˆìš©í•©ë‹ˆë‹¤.
### ì•± ì½”ë“œ
```bash
import sys
import re
import random
import pickle
import numpy as np
import tensorflow as tf
from PySide6.QtWidgets import QApplication, QWidget, QVBoxLayout, QLineEdit, QPushButton, QLabel, QScrollArea, QSlider, QComboBox
from PySide6.QtCore import Qt

# ì¸ì‚¬ íŒ¨í„´ ë° ì‘ë‹µ
greetings = [r"\bì•ˆë…•\b", r"\bì•ˆë…•í•˜ì„¸ìš”\b", r"\bë°˜ê°€ì›Œ\b", r"\bí•˜ì´\b", r"\bì˜ ì§€ë‚´\b"]
greeting_responses = ["ì•ˆë…•í•˜ì„¸ìš”! ğŸ˜Š", "ë°˜ê°‘ìŠµë‹ˆë‹¤!", "ì•ˆë…•! ì¢‹ì€ í•˜ë£¨ ë³´ë‚´!", "í•˜ì´~ ë­ ë„ì™€ì¤„ê¹Œ?"]

name_questions = [r"\bì´ë¦„ì´ ë­ì•¼\b", r"\bë„ˆ ëˆ„êµ¬ì•¼\b", r"\bë„ˆì˜ ì´ë¦„ì€\b", r"\bë„ˆ ë­ì•¼\b"]
name_responses = ["ë‚´ ì´ë¦„ì€ ë§ˆìŒì´ì•¼!", "ë‚œ ì±—ë´‡ ë§ˆìŒì´ì•¼, ë°˜ê°€ì›Œ!", "ë§ˆìŒì´ë¼ê³  ë¶ˆëŸ¬ì¤˜! ğŸ˜Š"]

# ëª¨ë¸ ë° í† í¬ë‚˜ì´ì € ë¶ˆëŸ¬ì˜¤ê¸°
def load_model(model_name):
    if model_name == "ê¸°ë³¸ ëª¨ë¸":
        model = tf.keras.models.load_model("seq2seq_model_90000.h5")
    elif model_name == "ê³ ê¸‰ ëª¨ë¸":
        model = tf.keras.models.load_model("seq2seq_model_98000.h5")
    elif model_name == "ë¹ ë¥¸ ëª¨ë¸":
        model = tf.keras.models.load_model("seq2seq_model_50000.h5")
    
    with open(f"tokenizer.pkl", "rb") as f:
        tokenizer = pickle.load(f)
    
    return model, tokenizer

# ì´ˆê¸° ëª¨ë¸ ì„¤ì • (ê¸°ë³¸ ëª¨ë¸)
model, tokenizer = load_model("ê¸°ë³¸ ëª¨ë¸")

start_token = "<start>"
end_token = "<end>"

# ì¸ì½”ë” ëª¨ë¸ ìƒì„±
encoder_inputs = model.input[0]
encoder_embedding = model.layers[2]
encoder_gru = model.layers[4]
encoder_outputs, state_h = encoder_gru(encoder_embedding(encoder_inputs))
encoder_model = tf.keras.Model(encoder_inputs, [encoder_outputs, state_h])

# ë””ì½”ë” ëª¨ë¸ ìƒì„±
decoder_inputs = model.input[1]
decoder_embedding = model.layers[3]
decoder_state_input_h = tf.keras.Input(shape=(136,))
decoder_embedded = decoder_embedding(decoder_inputs)
decoder_gru = model.layers[5]
decoder_outputs, decoder_state_h = decoder_gru(decoder_embedded, initial_state=decoder_state_input_h)
decoder_dense = model.layers[6]
decoder_outputs = decoder_dense(decoder_outputs)
decoder_model = tf.keras.Model([decoder_inputs, decoder_state_input_h], [decoder_outputs, decoder_state_h])

# ì¸ì‚¬ ì²´í¬ í•¨ìˆ˜
def is_greeting(text):
    return any(re.search(pattern, text.lower()) for pattern in greetings)

def is_name_question(text):
    return any(re.search(pattern, text.lower()) for pattern in name_questions)

# ì±—ë´‡ ì‘ë‹µ í•¨ìˆ˜
def chatbot_response(user_input, temperature=0.7):
    if is_greeting(user_input):
        return random.choice(greeting_responses)
    elif is_name_question(user_input):
        return random.choice(name_responses)
    return chat_with_model(user_input, temperature)

# ì±„íŒ… í•¨ìˆ˜
def chat_with_model(input_text, temperature):
    input_seq = tokenizer.texts_to_sequences([input_text])
    input_seq = tf.keras.preprocessing.sequence.pad_sequences(input_seq, maxlen=40, padding="post")

    encoder_output, state_h = encoder_model.predict(input_seq)
    target_seq = np.array([[tokenizer.word_index[start_token]]])
    stop_condition = False
    decoded_sentence = ""
    prev_words = []

    max_output_length = 58
    while not stop_condition:
        output_tokens, h = decoder_model.predict([target_seq, state_h])
        preds = np.asarray(output_tokens[0, -1, :]).astype("float64")
        preds = np.log(preds + 1e-8) / temperature
        exp_preds = np.exp(preds)
        preds = exp_preds / np.sum(exp_preds)

        sampled_token_index = np.random.choice(len(preds), p=preds)
        sampled_word = tokenizer.index_word.get(sampled_token_index, "")

        if not sampled_word or sampled_word in prev_words:
            continue

        prev_words.append(sampled_word)
        if len(prev_words) > 3:
            prev_words.pop(0)

        if sampled_word == end_token or len(decoded_sentence.split()) >= max_output_length:
            stop_condition = True
        else:
            decoded_sentence += " " + sampled_word

        target_seq = np.array([[sampled_token_index]])
        state_h = h

    return decoded_sentence.strip()

# PySide6 GUI í´ë˜ìŠ¤
class ChatWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Chatbot GUI")
        self.setGeometry(100, 100, 400, 600)
        layout = QVBoxLayout()

        # ëª¨ë¸ ì„ íƒ ì½¤ë³´ë°•ìŠ¤
        self.model_selector = QComboBox(self)
        self.model_selector.addItem("ê¸°ë³¸ ëª¨ë¸")
        self.model_selector.addItem("ê³ ê¸‰ ëª¨ë¸")
        self.model_selector.addItem("ë¹ ë¥¸ ëª¨ë¸")
        self.model_selector.currentTextChanged.connect(self.change_model)
        
        self.chat_area = QScrollArea(self)
        self.chat_widget = QWidget()
        self.chat_layout = QVBoxLayout()
        self.chat_widget.setLayout(self.chat_layout)
        self.chat_area.setWidget(self.chat_widget)
        self.chat_area.setWidgetResizable(True)

        self.text_input = QLineEdit(self)
        self.text_input.setPlaceholderText("ë©”ì‹œì§€ë¥¼ ì…ë ¥í•˜ì„¸ìš”...")
        self.text_input.returnPressed.connect(self.send_message)

        self.send_button = QPushButton("ë³´ë‚´ê¸°", self)
        self.send_button.clicked.connect(self.send_message)

        self.temperature_slider = QSlider(Qt.Horizontal)
        self.temperature_slider.setMinimum(10)
        self.temperature_slider.setMaximum(100)
        self.temperature_slider.setValue(70)
        self.temperature_slider.valueChanged.connect(self.update_temperature)
        self.temperature_label = QLabel(f"Temperature: {self.temperature_slider.value() / 100:.2f}", self)

        layout.addWidget(QLabel("ëª¨ë¸ ì„ íƒ:"))
        layout.addWidget(self.model_selector)
        layout.addWidget(self.temperature_label)
        layout.addWidget(self.temperature_slider)
        layout.addWidget(self.chat_area)
        layout.addWidget(self.text_input)
        layout.addWidget(self.send_button)

        self.setLayout(layout)
        self.apply_dark_mode()

    def send_message(self):
        user_message = self.text_input.text().strip()
        if not user_message:
            return

        self.display_message(f"You: {user_message}", "user")
        response = chatbot_response(user_message, self.temperature_slider.value() / 100)
        self.display_message(f"ë§ˆìŒì´: {response}", "bot")
        self.text_input.clear()

    def display_message(self, message, sender):
        label = QLabel(message, self)
        label.setStyleSheet("color: white; background-color: #007BFF; padding: 5px; border-radius: 10px;" if sender == "bot" else "color: red; background-color: #f1f1f1; padding: 5px; border-radius: 10px;")
        self.chat_layout.addWidget(label)
        self.chat_area.verticalScrollBar().setValue(self.chat_area.verticalScrollBar().maximum())

    def update_temperature(self):
        temp = self.temperature_slider.value() / 100
        self.temperature_label.setText(f"Temperature: {temp:.2f}")

    def change_model(self, model_name):
        global model, tokenizer
        model, tokenizer = load_model(model_name)

    def apply_dark_mode(self):
        self.setStyleSheet("""
            QWidget { background-color: #2b2b2b; color: white; }
            QLineEdit, QPushButton { background-color: #444444; color: white; border: 1px solid #888888; }
            QLabel { color: white; }
        """)

if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = ChatWindow()
    window.show()
    sys.exit(app.exec())
